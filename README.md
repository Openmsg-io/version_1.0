# version_1.0

Visit https://www.openmsg.io
Visit https://www.openmsg.io/docs/ for integration guides
Contact: https://www.openmsg.io/pages/contact/ >> My Openmsg address: 1*openmsg.io

# Openmsg: The spam free, open messaging protocol
Openmsg was built as an alternative to email by someone who was fed up of spam. It is an open, cross-platform, decentralized messaging protocol that anyone can implement. All you need is a domain name and a database. Developers can build their own clients and servers in any programming language.


# Key Features
#Spam-free
The Openmsg protocol is designed from the ground up to be spam-free. One user cannot connect with another without explicit permission. For example, if user A wants to connect with user B, they need to know not only user B's Openmsg address but also possess a one-time passcode that was issued by user B. Without a valid passcode, any connection attempt will silently fail—user B won’t even be notified. That means: no spam messages, no spam requests, no noise.

# Open Protocol
Openmsg is an open protocol — anyone is free to implement it. While most examples on this site use PHP and MySQL for simplicity, the protocol itself is platform-independent and can be implemented in any programming language of your choice.

# Decentralized
The protocol is fully decentralized — there’s no central server or authority. Anyone with a domain name and a database can run their own server node, giving them complete control over their messaging system while still being able to communicate with others using the same protocol.

# Encryption Built-in
A key feature of the protocol is built-in end-to-end encryption. When two users first connect, they securely exchange both encryption keys and authorization codes for ongoing communication.
Authorization codes verify permission to exchange messages between the users.
Encryption keys ensure that all messages are encrypted end-to-end, keeping content private.
Each message is accompanied by a unique hash generated by the sender, based on the message content and timestamp. This allows the recipient’s server to verify that the message is authentic and recent. Once a message hash has been used, it cannot be reused, preventing replay attacks.

# Spoof-proof
Openmsg is designed to prevent spoofed or forged messages—even in the event of an authorization code leak. If authorization codes are exposed in a data breach, they cannot be used by another server or domain to impersonate the original sender. This is because of a core security feature: When a message is received, the receiving server always verifies its authenticity by contacting the sender’s original server directly. The message is only accepted if the expected server confirms that it actually sent it. This ensures that even if someone has the correct authorization codes, they cannot spoof a message unless they are operating from the legitimate sender’s domain.

# Easy to Implement
Setting up a server is simple—all you need is a database and a few files. You can setup the protocol on any domain in just a few steps:
Set up the database tables (we provide PHP code to create the necessary tables in just a few clicks)
Download the PHP files and upload to your server
Tweak the configuration to match your server settings.

If you're not using PHP, the provided code can be used as a reference and easily adapted to any programming language. Infomormation packages are sent using cURL / JSON.


# Get Started

# Roles
There are 2 roles: a Server Node and a User.
The Server Node (Node) is a computer server that can send and receive messages.
The User has an account with the provider of a Node, and can log in to send and view messages.
The protocol is designed to work between Server Nodes, each of which can send and receive messages. Internally, Nodes have two main components:
The Sending Component, which handles outbound messages
The Receiving Component, which accepts and processes inbound messages
While it's possible to run a Node in send-only or receive-only mode, most setups include both for full communication.

# Setup
To set up a Node you will need a domain name / website and a database. At the very least you will need to set up your database (to store auth_codes and ident_codes, store messages and user data etc) and set up your code (to be able to send / receive messages).

# Account Address Fromat
Accounts use a numeric address ID, followed by an asterix, then the domain, like so: 06290345*domain.com or 123456*openmsg.io
Because the address ID (the part left of the asterix) is stored as a string, it can start with zeros. However all the characters in the ID must be numeric. For example, 000000*openmsg.io is a valid address. However abcdefg*openmsg.io is not valid.

The numeric ID is unique per domain. So 1234*domain-a.com is a different to 1234*domain-b.com

# Overview
The initial handshake: The initial handshakes establishes a trust between two Nodes. It proves to the receiving Node that the sending Node has permission to connect, and then send messages to the User. Durin the handshake an authorizations code and an encryption key are created and stored by each server.
Sending a message: Messages are encrypted and a unique hash is created using the message, auth code and timestamp to ensure that the sender is geniune (has the auth code), and to prevent replay attacks and ensure message integrity.
Receiving a message: The receiving server Node verifies the hash.
Verifying the sender: Before accepting the message, the receiving server Node contacts the original sender's server Node (established during the handshake) to confirm it actually sent this message, proving the message came from the correct domain.

# Initial Handshake
1. One-Time Handshake: Establishing Trust

Before two users can exchange messages, a one-time handshake must take place. This is initiated when:
User B has a valid pass code and address for User A.
User B’s server contacts User A’s server node to initiate the handshake.

During this handshake:
A shared identification code is generated and stored by both servers.
A shared authorization code is generated and stored by both servers.
A shared encryption key is exchanged.
The servers remember each other’s domain and user identity.

This step is mutual and must be completed before messaging can begin.

# Sending a Message
Sending a Message: Encryption and Hashing

When User B wants to send a message to User A, User B’s server creates a message package containing:
The encrypted message
The encryption nonce
The current UNIX timestamp
A hash, created from:
The private auth code
The encrypted message and nonce, and timestamp
A random salt
Note: The auth code itself is never sent. Both servers already have it from the initial handshake.

# Receiving a Message
Receiving a Message: Verifying Authenticity

When User A’s server receives the package, it performs the following checks:
Recreates the hash using:
Its own copy of the auth code (from the handshake)
The received encrypted message and nonce, the salt, and the timestamp
Validates that:
The hash matches → proves the sender knows the auth code
The timestamp is genuine and recent (e.g., within 60 seconds) → prevents replay attacks
The message wasn’t altered → ensures data integrity

If these checks pass, the message appears authentic on the cryptographic level.

# Verify the Sender
Verifying the Sender’s Server

Before accepting the message, the User A’s server Node (the receiving Node) contacts the sender's original server Node (User B’s) to confirm it actually sent this message.:
A cURL request is made to User B’s server with the hash.
If User B’s server acknowledges the message was just sent, it proves:
The message came from the correct domain
No other server is impersonating User B
Only then does User A’s server accept the message.

Note: The original server is established in the handshake, and is taken from the domain name in the User's address/
